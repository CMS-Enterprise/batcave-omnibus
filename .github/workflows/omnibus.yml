name: Build Omnibus
run-name: "Building Omnibus Image: ${{ github.event.head_commit.message }}"
on:
  push:
    branches:
      - main
      - feat/*
    tags:
      - "*"
  pull_request:
    branches:
      - main

jobs:
  delivery:
    runs-on: ubuntu-latest
    outputs:
      IMAGE_NAME: ${{ steps.output.outputs.IMAGE_NAME }}
    steps:
      - uses: actions/checkout@v4

      # In order to support caching we need to make sure we are using the docker-container driver for builds
      # - name: Restore image layer cache
      #   uses: actions/cache/restore@v4
      #   with:
      #     path: ./container-cache-in
      #     key: ${{ runner.os }}-
      #     restore-keys: |
      #       layers-${{ runner.os }}-${{ github.ref }}-${{ hashFiles('Dockerfile') }}
      #       layers-${{ runner.os }}-${{ github.ref }}
      #       layers-${{ runner.os }}

      - id: string
        uses: ASzc/change-string-case-action@v5
        with:
          string: ${{ github.repository }}
      - name: Convert repository name to lowercase
        run: |
          echo "REPO_NAME=${{ steps.string.outputs.lowercase }}" >> $GITHUB_ENV
      - name: Set up the environment
        run: |
          if [[ $GITHUB_REF == refs/heads/* ]]; then
            echo "IMAGE_NAME=ghcr.io/${{ env.REPO_NAME }}:testing" >> $GITHUB_ENV
          else
            echo "IMAGE_NAME=ghcr.io/${{ env.REPO_NAME }}:$GITHUB_REF_NAME" >> $GITHUB_ENV
          fi
      - name: Print environment
        run: |
          echo "IMAGE_NAME=${{ env.IMAGE_NAME }}"

      # TODO combine all delivery jobs into a single action
      - name: Build container image
        uses: CMS-Enterprise/batcave-workflow-engine/.github/actions/image-build@feat/github-actions
        with:
          path: .
          # TODO: the dockerfile path should be relative to the context path
          dockerfile: ./Dockerfile
          # TODO: add support for mixed case to workflow-engine (i.e. we should force container image tags to lowercase)
          image_tag: ${{ env.IMAGE_NAME }}
          # cache_from: ./container-cache-in
          # cache_to: ./container-cache-out
          repo_token: ${{ secrets.GITHUB_TOKEN }}

      # - name: Save image layer cache
      #   uses: actions/cache/save@v4
      #   with:
      #     path: ./container-cache-out
      #     key: layers-${{ runner.os }}-${{ github.ref }}-${{ hashFiles('Dockerfile') }}

      - name: Scan container image
        uses: CMS-Enterprise/batcave-workflow-engine/.github/actions/image-scan@feat/github-actions
        with:
          image_tag: ${{ env.IMAGE_NAME }}
          output_dir: ./artifacts
          repo_token: ${{ secrets.GITHUB_TOKEN }}

      # TODO: this should be something workflow-engine does as apart of the delivery pipeline
      - name: Push image
        # TODO: in the future push based on protected git tags
        # if: ${{ startsWith(github.ref, 'refs/tags/v') }}
        shell: bash
        run: docker push ${{ env.IMAGE_NAME }}

      - name: Archive image scan outputs
        uses: actions/upload-artifact@v4
        with:
          name: image-scan-results
          path: ./artifacts/*.json
          if-no-files-found: error

      - id: output
        run: |
          echo "IMAGE_NAME=${{ env.IMAGE_NAME }}"
          echo "IMAGE_NAME=${{ env.IMAGE_NAME }}" >> $GITHUB_OUTPUT

  # build-image:
  #   runs-on: ubuntu-latest
  #   outputs:
  #     IMAGE_NAME: ${{ steps.output.outputs.IMAGE_NAME }}
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
  #     - name: Set up QEMU
  #       uses: docker/setup-qemu-action@v3
  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3
  #     - name: Login to GitHub Container Registry
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ghcr.io
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}
  #     - id: string
  #       uses: ASzc/change-string-case-action@v6
  #       with:
  #         string: ${{ github.repository }}
  #     - name: Convert repository name to lowercase
  #       run: |
  #         echo "REPO_NAME=${{ steps.string.outputs.lowercase }}" >> $GITHUB_ENV
  #     - name: Set up the environment
  #       run: |
  #         if [[ $GITHUB_REF == refs/heads/* ]]; then
  #           echo "IMAGE_NAME=omnibus:latest" >> $GITHUB_ENV
  #         else
  #           echo "IMAGE_NAME=ghcr.io/${{ env.REPO_NAME }}:$GITHUB_REF_NAME" >> $GITHUB_ENV
  #         fi
  #     - name: Print environment
  #       run: |
  #         echo "IMAGE_NAME=${{ env.IMAGE_NAME }}"
  #     - name: Build Image
  #       uses: docker/build-push-action@v5
  #       with:
  #         context: .
  #         load: true
  #         tags: ${{ env.IMAGE_NAME }}
  #     - name: Test
  #       run: |
  #         docker run --rm ${{ env.IMAGE_NAME }}
  #     - name: Push Image for later jobs
  #       uses: docker/build-push-action@v2
  #       with:
  #         context: .
  #         tags: ${{ env.IMAGE_NAME }}
  #         outputs: type=docker,dest=/tmp/myimage.tar
  #     - name: Upload artifact
  #       uses: actions/upload-artifact@v2
  #       with:
  #         name: myimage
  #         path: /tmp/myimage.tar
  #     - name: Push Image if tag
  #       # if: startsWith(github.ref, 'refs/tags/v')
  #       uses: docker/build-push-action@v5
  #       with:
  #         context: .
  #         platforms: linux/amd64,linux/arm64
  #         push: true
  #         tags: ${{ env.IMAGE_NAME }}
  #     - name: Inspect
  #       run: |
  #         docker image inspect ${{ env.IMAGE_NAME }}
  #     - id: output
  #       name: Set the output
  #       run: echo "IMAGE_NAME=${{ env.IMAGE_NAME }}" >> $GITHUB_OUTPUT

  # load-image:
  #   runs-on: ubuntu-latest
  #   needs: build-image
  #   steps:
  #     - name: Download image from artifact
  #       uses: actions/download-artifact@v3
  #       with:
  #         name: myimage
  #         path: /tmp
  #     - name: Load saved image
  #       run: docker load < /tmp/myimage.tar

  grype:
    needs: [delivery]
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.delivery.outputs.IMAGE_NAME }}
    env:
      IMAGE_NAME: ${{ needs.delivery.outputs.IMAGE_NAME }}
      # BC_IMAGE_REPO: ghcr.io/batcave-docker
      # APP_IMAGE_TAG: ${{ github.sha }}
      # APP_IMAGE_SRC: ${{ vars.BC_IMAGE_REPO }}/${{ github.repository }}
      # APP_IMAGE: ${{ vars.BC_IMAGE_REPO }}/${{ github.repository }}:${{ github.sha }}
      # ARTIFACT_FOLDER: ".artifacts"
      # GITLEAKS_REPORT: ".artifacts/gitleaks/gitleaks_report.json"
      # IMAGE_SBOM: ".artifacts/sbom/sbom.json"
      # COSIGN_EXPERIMENTAL: 1
      GRYPE_CACHE_IMAGE: "${{ vars.BC_IMAGE_REPO }}/devops-pipelines/cache/grype/vulndb:latest"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Test Grype
        run: |
          echo "IMAGE_NAME=${{ env.IMAGE_NAME }}"
          echo "GRYPE_CACHE_IMAGE=${{ env.GRYPE_CACHE_IMAGE }}"
          grype version
      # TODO: Add these steps when there is access to artifactory
      # - run: oras pull ${GRYPE_CACHE_IMAGE}
      # - run: grype db import vulndb.tar.gz
      # - run: grype db check
      # - run: grype artifactory.cloud.cms.gov/docker/bkimminich/juice-shop -o json --file report.json
      # - run: cat report.json | jq .

  syft:
    needs: [delivery]
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.delivery.outputs.IMAGE_NAME }}
    env:
      IMAGE_NAME: ${{ needs.delivery.outputs.IMAGE_NAME }}
      IMAGE_SBOM: ".artifacts/sbom/sbom.json"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      # - name: Login to GitHub Container Registry
      #   uses: docker/login-action@v3
      #   with:
      #     registry: ghcr.io
      #     username: ${{ github.actor }}
      #     password: ${{ secrets.GITHUB_TOKEN }}
      # - name: Login to Docker Hub
      #   uses: docker/login-action@v3
      #   with:
      #     username: ${{ secrets.BC_DOCKERHUB_USERNAME }}
      #     password: ${{ secrets.BC_DOCKERHUB_PASSWORD }}
      # - name: Download artifact
      #   uses: actions/download-artifact@v3
      #   with:
      #     name: myimage
      #     path: /tmp
      # - name: Load Docker image
      #   # - run: mkdir ~/.docker && echo $BC_ARTIFACTORY_AUTH_JSON >> ~/.docker/config.json
      #   run: |
      #     docker load --input /tmp/myimage.tar
      #     docker image ls -a
      #     docker run --entrypoint=/bin/sh ${{ env.IMAGE_NAME }} -c 'syft version'
      #     docker run --entrypoint=/bin/sh ${{ env.IMAGE_NAME }} -c 'syft hub.docker.com/bkimminich/juice-shop-ctf --scope=squashed -o json --file ${IMAGE_SBOM}; cat ${IMAGE_SBOM}'
      - name: Test Syft
        run: |
          syft version
      # Since this container does not contain docker, we need to create an image for juice shop and use it here
      # syft hub.docker.com/bkimminich/juice-shop-ctf --scope=squashed -o json --file ${IMAGE_SBOM}
      # cat ${IMAGE_SBOM}

  gitleaks:
    needs: [delivery]
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.delivery.outputs.IMAGE_NAME }}
    env:
      ARTIFACT_FOLDER: ".artifacts"
      GITLEAKS_REPORT: ".artifacts/gitleaks/gitleaks_report.json"
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Test GitLeaks
        run: |
          git config --global --add safe.directory '*'
          git clone https://github.com/juice-shop/juice-shop.git
          mkdir -p ${{ env.ARTIFACT_FOLDER }}/gitleaks
          touch ${GITLEAKS_REPORT}
          echo "Starting Gitleaks Secrets Scan"
          gitleaks detect --exit-code 0 --verbose --source juice-shop --report-format json --report-path ${GITLEAKS_REPORT}

  cosign-crane:
    needs: [delivery]
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.delivery.outputs.IMAGE_NAME }}
    env:
      # TEMPLATE_VERSION: main
      # FETCH_SAST_ARTIFACTS: "false"
      APP_IMAGE_TAG: ${{ github.sha }}
      APP_IMAGE_SRC: ${{ vars.BC_IMAGE_REPO }}/${{ github.repository }}
      APP_IMAGE: ${{ vars.BC_IMAGE_REPO }}/${{ github.repository }}:${{ github.sha }}
      # ARTIFACT_FOLDER: ".artifacts"
      # GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
      # IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
      # COSIGN_EXPERIMENTAL: 1
    steps:
      - uses: actions/checkout@v4.1.0
      - name: Test Cosign/Crane
        run: |
          cosign version
          crane version
          export TARGET_IMAGE=$(crane digest --full-ref ${APP_IMAGE})
          echo "Application Image Digest -> ${TARGET_IMAGE}"
          echo "Signing image using cosign with OIDC token"
        # TODO: Add the following when I figure out where this token comes from
        # cosign sign --identity-token=$(cat /var/run/secrets/eks.amazonaws.com/serviceaccount/token) ${TARGET_IMAGE}

  gatecheck:
    needs: [delivery]
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.delivery.outputs.IMAGE_NAME }}
    # env:
    #   TEMPLATE_VERSION: main
    #   FETCH_SAST_ARTIFACTS: 'false'
    #   APP_IMAGE_TAG: "${{ github.sha }}"
    #   APP_IMAGE_SRC: "${BC_IMAGE_REPO}/${{ github.repository }}"
    #   APP_IMAGE: "${APP_IMAGE_SRC}:${APP_IMAGE_TAG}"
    #   ARTIFACT_FOLDER: ".artifacts"
    #   GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
    #   IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
    #   COSIGN_EXPERIMENTAL: 1
    steps:
      - uses: actions/checkout@v4.1.0
      - name: Test Gatecheck
        run: |
          gatecheck version
          gatecheck config info

  s3upload:
    needs: [delivery]
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.delivery.outputs.IMAGE_NAME }}
    env:
      # TEMPLATE_VERSION: main
      # FETCH_SAST_ARTIFACTS: "false"
      # APP_IMAGE_TAG: "${{ github.sha }}"
      # APP_IMAGE_SRC: "${BC_IMAGE_REPO}/${{ github.repository }}"
      # APP_IMAGE: "${APP_IMAGE_SRC}:${APP_IMAGE_TAG}"
      # ARTIFACT_FOLDER: ".artifacts"
      # GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
      # IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
      # COSIGN_EXPERIMENTAL: 1
      AWS_PROFILE: "${{ secrets.BC_AWS_PROFILE_PROD }}"
      AWS_BUCKET: "${{ secrets.BC_AWS_SECURITY_SCANS_STORAGE_BUCKET_PROD }}"
      PRODUCT: "${{ github.event.repository.name }}"
      # ENGAGEMENT: "${{ github.event.repository.name }}_pipeline_${{ github.repository}}/${{ github.workflow }}_${{ github.ref }}"
      ENGAGEMENT: "${{ github.event.repository.name }}_pipeline_${{ github.repository}}"
    steps:
      - uses: actions/checkout@v4.1.0
      - name: Test S3 Upload
        run: |
          echo "github.repository_owner=${{ github.repository_owner }}"
          echo "github.workflow=${{ github.workflow }}"
          echo "github.ref=${{ github.ref }}"
          echo "PRODUCT=${{ env.PRODUCT}}"
          echo "ENGAGEMENT=${{ env.ENGAGEMENT}}"
          # export PRODUCT_TYPE=$(basename ${{ github.repository_owner }})
          export EXPORT_DATE=$(date -u +"%Y%m%d")
          export S3_KEY=${EXPORT_DATE}/${{ env.PRODUCT }}/${{ env.ENGAGEMENT }}
          echo "Omnibus Smoke Test - Ignore" > file-1.txt

          # echo "PRODUCT_TYPE=${PRODUCT_TYPE}"
          echo "EXPORT_DATE=${EXPORT_DATE}"
          echo "S3_KEY=${S3_KEY}"
          echo "AWS_BUCKET=${{ env.AWS_BUCKET }}"

          ls -la
          s3upload -f file-1.txt -b ${{ env.AWS_BUCKET }} -k ${S3_KEY}

  oras:
    needs: [delivery]
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.delivery.outputs.IMAGE_NAME }}
    env:
      # TEMPLATE_VERSION: main
      # FETCH_SAST_ARTIFACTS: "false"
      # APP_IMAGE_TAG: "${{ github.sha }}"
      # APP_IMAGE_SRC: "${{ vars.BC_IMAGE_REPO }}/${{ github.repository }}"
      # APP_IMAGE: "${APP_IMAGE_SRC}:${APP_IMAGE_TAG}"
      # ARTIFACT_FOLDER: ".artifacts"
      # GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
      # IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
      # COSIGN_EXPERIMENTAL: 1
      ARTIFACT_TYPE: application/vnd.cms.batcave.smoke-test+text
      SMOKE_TEST_IMAGE: "${{ vars.BC_IMAGE_REPO }}/devops-pipelines/cache/omnibus/smoke-test:latest"
    steps:
      - uses: actions/checkout@v4.1.0
      - name: Test Oras
        run: |
          date > omnibus-smoke-test.txt
          cat omnibus-smoke-test.txt
        # TODO: Add this after moving the smoke test image to ghcr.io
        # oras push -v --artifact-type ${{ env.ARTIFACT_TYPE }} ${{ env.SMOKE_TEST_IMAGE }} omnibus-smoke-test.txt
        # rm omnibus-smoke-test.txt
        # ls -lah
        # oras pull -v ${{ env.SMOKE_TEST_IMAGE }}
        # cat omnibus-smoke-test.txt

  workflow-engine:
    needs: [delivery]
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.delivery.outputs.IMAGE_NAME }}
    env:
      # TEMPLATE_VERSION: main
      # FETCH_SAST_ARTIFACTS: "false"
      # APP_IMAGE_TAG: "${{ github.sha }}"
      # APP_IMAGE_SRC: "${BC_IMAGE_REPO}/${{ github.repository }}"
      # APP_IMAGE: "${APP_IMAGE_SRC}:${APP_IMAGE_TAG}"
      # ARTIFACT_FOLDER: ".artifacts"
      # GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
      # IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
      # COSIGN_EXPERIMENTAL: 1
      WFE_BUILD_DIR: "."
      WFE_BUILD_DOCKERFILE: Dockerfile
      WFE_BUILD_TAG: latest
      WFE_BUILD_PLATFORM: linux/amd64
      WFE_BUILD_TARGET: build
      WFE_BUILD_CACHE_TO: ""
      WFE_BUILD_CACHE_FROM: ""
      WFE_BUILD_SQUASH_LAYERS: "false"
      WFE_SCAN_IMAGE_TARGET: ""
      WFE_ARTIFACT_DIRECTORY: ".artifacts"
      WFE_SBOM_FILENAME: sbom.json
      WFE_GRYPE_FILENAME: grype.json
    steps:
      - uses: actions/checkout@v4.1.0
      - name: Test Workflow Engine
        run: |
          echo "Workflow Engine Smoke Test"
          workflow-engine run debug

  semgrep:
    needs: [delivery]
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.delivery.outputs.IMAGE_NAME }}
    env:
      ARTIFACT_FOLDER: ".artifacts"
    steps:
      - name: Test Semgrep
        run: |
          mkdir -p ${{ env.ARTIFACT_FOLDER }}/sast/
          osemgrep --help
          osemgrep --experimental ci --json > ${{ env.ARTIFACT_FOLDER }}/sast/semgrep-sast-report.json || true
          cat ${{ env.ARTIFACT_FOLDER }}/sast/semgrep-sast-report.json

  release-tool:
    needs: [delivery]
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.delivery.outputs.IMAGE_NAME }}
    steps:
      - name: Release Omnibus
        run: |
          echo "Releasing Omnibus..."
        # TODO: Figure out equivalent release tool for GitHub Actions
        # gh help

  # _with-omnibus:
  #   runs-on: ubuntu-latest
  #   container:
  #     image: artifactory.cloud.cms.gov/batcave-docker/devops-pipelines/pipeline-tools/omnibus:v1.0.0

  # release-pipeline
  #
  # create a release when there is a git tag pushed to this repo
  # release-pipeline:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v2

  #     - name: Create a release when there is a git tag pushed to this repo
  #       run: |
  #         # TODO: Call release-pipeline in pipeline triggers

  # release-gitlab
  #
  # creates a release package for GitLab UI
  # release-gitlab:
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v2

  #     - name: Creates a release package for GitLab UI
  #       run: |
  #         echo "Release to GitLab..."
  #         # TODO: Call release-gitlab in pipeline triggers

  # _with-current-image:
  #   # needs: delivery-pipeline
  #   # TODO: Invert the following condition:
  #   # if the current branch is not a tag, then run the pipeline
  #   # if: startsWith(github.ref, 'refs/tags/v')
  #   runs-on: ubuntu-latest
  #   container:
  #     # image: "${APP_IMAGE}"
  #     image: ${{ vars.BC_IMAGE_REPO }}/${{ github.repository }}:${{ github.sha }}
  #   env:
  #     BC_IMAGE_REPO: ${{ secrets.BC_ARTIFACTORY_URL }}/batcave-docker
  #     APP_IMAGE_TAG: ${{ github.sha }}
  #     APP_IMAGE_SRC: ${{ vars.BC_IMAGE_REPO }}/${{ github.repository }}
  #     # APP_IMAGE: ${{ vars.BC_IMAGE_REPO }}/${{ github.repository }}:${{ github.sha }}
  #     APP_IMAGE: ${APP_IMAGE_SRC}:${{ github.sha }}
  #     ARTIFACT_FOLDER: ".artifacts"
  #     GITLEAKS_REPORT: ${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json
  #     IMAGE_SBOM: ${ARTIFACT_FOLDER}/sbom/sbom.json
  #     COSIGN_EXPERIMENTAL: 1
  #   steps:
  #     - id: string
  #       uses: ASzc/change-string-case-action@v5
  #       with:
  #         string: ${{ github.repository }}

  #     - name: Concatenate values to environment file
  #       run: |
  #         echo "APP_IMAGE=${{env.BC_IMAGE_REPO}}/${{ steps.string.outputs.lowercase }}:${{ github.sha }}"
  #         echo "APP_IMAGE=${{env.BC_IMAGE_REPO}}/${{ steps.string.outputs.lowercase }}:${{ github.sha }}" >> $GITHUB_ENV

  #     - name: Checkout code
  #       uses: actions/checkout@v2

  #     - name: Setup Docker
  #       run: |
  #         mkdir ~/.docker && echo ${{ secrets.BC_ARTIFACTORY_AUTH_JSON }} >> ~/.docker/config.json
  #         run: echo 'BC_IMAGE_REPO: ${{ env.BC_IMAGE_REPO }}'

  # grype:
  #   needs: _with-current-image
  #   runs-on: ubuntu-latest
  #   # TODO: Fix syntax on the following
  #   # if: !(${{ github.event_name }} == "merge_request_event") || always() || !(${{ github.ref }}) || always()
  #   env:
  #     GRYPE_CACHE_IMAGE: "${BC_IMAGE_REPO}/devops-pipelines/cache/grype/vulndb:latest"
  #   steps:
  #     - uses: actions/checkout@v4.1.0
  #     - run: oras pull ${GRYPE_CACHE_IMAGE}
  #     - run: grype db import vulndb.tar.gz
  #     - run: grype db check
  #     - run: grype artifactory.cloud.cms.gov/docker/bkimminich/juice-shop -o json --file report.json
  #     - run: cat report.json | jq .

  # syft:
  #   needs: delivery-pipeline
  #   runs-on: ubuntu-latest
  #   container:
  #     image: "${APP_IMAGE}"
  #   if: !(${{ github.event_name }} == "merge_request_event") || always() || !(${{ github.ref }}) || always()
  #   env:
  #     TEMPLATE_VERSION: main
  #     FETCH_SAST_ARTIFACTS: 'false'
  #     APP_IMAGE_TAG: "${{ github.sha }}"
  #     APP_IMAGE_SRC: "${BC_IMAGE_REPO}/${{ github.repository }}"
  #     APP_IMAGE: "${APP_IMAGE_SRC}:${APP_IMAGE_TAG}"
  #     ARTIFACT_FOLDER: ".artifacts"
  #     GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
  #     IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
  #     COSIGN_EXPERIMENTAL: 1
  #   steps:
  #   - uses: actions/checkout@v4.1.0
  #   - run: mkdir ~/.docker && echo $BC_ARTIFACTORY_AUTH_JSON >> ~/.docker/config.json
  #   - run: syft version
  #   - run: syft artifactory.cloud.cms.gov/docker/bkimminich/juice-shop --scope=squashed -o json --file ${IMAGE_SBOM}
  #   - run: cat ${IMAGE_SBOM}
  # gitleaks:
  #   needs: delivery-pipeline
  #   runs-on: ubuntu-latest
  #   container:
  #     image: "${APP_IMAGE}"
  #   if: !(${{ github.event_name }} == "merge_request_event") || always() || !(${{ github.ref }}) || always()
  #   env:
  #     TEMPLATE_VERSION: main
  #     FETCH_SAST_ARTIFACTS: 'false'
  #     APP_IMAGE_TAG: "${{ github.sha }}"
  #     APP_IMAGE_SRC: "${BC_IMAGE_REPO}/${{ github.repository }}"
  #     APP_IMAGE: "${APP_IMAGE_SRC}:${APP_IMAGE_TAG}"
  #     ARTIFACT_FOLDER: ".artifacts"
  #     GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
  #     IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
  #     COSIGN_EXPERIMENTAL: 1
  #   steps:
  #   - uses: actions/checkout@v4.1.0
  #   - run: mkdir ~/.docker && echo $BC_ARTIFACTORY_AUTH_JSON >> ~/.docker/config.json
  #   - run: git config --global --add safe.directory '*'
  #   - run: git clone https://github.com/juice-shop/juice-shop.git
  #   - run: mkdir -p $ARTIFACT_FOLDER/gitleaks
  #   - run: touch ${GITLEAKS_REPORT}
  #   - run: echo "Starting Gitleaks Secrets Scan"
  #   - run: gitleaks detect --exit-code 0 --verbose --source juice-shop --report-format json --report-path ${GITLEAKS_REPORT}
  # cosign-crane:
  #   needs: delivery-pipeline
  #   runs-on: ubuntu-latest
  #   container:
  #     image: "${APP_IMAGE}"
  #   if: !(${{ github.event_name }} == "merge_request_event") || always() || !(${{ github.ref }}) || always()
  #   env:
  #     TEMPLATE_VERSION: main
  #     FETCH_SAST_ARTIFACTS: 'false'
  #     APP_IMAGE_TAG: "${{ github.sha }}"
  #     APP_IMAGE_SRC: "${BC_IMAGE_REPO}/${{ github.repository }}"
  #     APP_IMAGE: "${APP_IMAGE_SRC}:${APP_IMAGE_TAG}"
  #     ARTIFACT_FOLDER: ".artifacts"
  #     GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
  #     IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
  #     COSIGN_EXPERIMENTAL: 1
  #   steps:
  #   - uses: actions/checkout@v4.1.0
  #   - run: mkdir ~/.docker && echo $BC_ARTIFACTORY_AUTH_JSON >> ~/.docker/config.json
  #   - run: cosign version
  #   - run: crane version
  #   - run: export TARGET_IMAGE=$(crane digest --full-ref ${APP_IMAGE})
  #   - run: echo "Application Image Digest -> ${TARGET_IMAGE}"
  #   - run: echo "Signing image using cosign with OIDC token"
  #   - run: cosign sign --identity-token=$(cat /var/run/secrets/eks.amazonaws.com/serviceaccount/token) ${TARGET_IMAGE}
  # gatecheck:
  #   needs: delivery-pipeline
  #   runs-on: ubuntu-latest
  #   container:
  #     image: "${APP_IMAGE}"
  #   if: !(${{ github.event_name }} == "merge_request_event") || always() || !(${{ github.ref }}) || always()
  #   env:
  #     TEMPLATE_VERSION: main
  #     FETCH_SAST_ARTIFACTS: 'false'
  #     APP_IMAGE_TAG: "${{ github.sha }}"
  #     APP_IMAGE_SRC: "${BC_IMAGE_REPO}/${{ github.repository }}"
  #     APP_IMAGE: "${APP_IMAGE_SRC}:${APP_IMAGE_TAG}"
  #     ARTIFACT_FOLDER: ".artifacts"
  #     GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
  #     IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
  #     COSIGN_EXPERIMENTAL: 1
  #   steps:
  #   - uses: actions/checkout@v4.1.0
  #   - run: mkdir ~/.docker && echo $BC_ARTIFACTORY_AUTH_JSON >> ~/.docker/config.json
  #   - run: gatecheck version
  #   - run: gatecheck config info
  # s3upload:
  #   needs: delivery-pipeline
  #   runs-on: ubuntu-latest
  #   container:
  #     image: "${APP_IMAGE}"
  #   if: !(${{ github.event_name }} == "merge_request_event") || always() || !(${{ github.ref }}) || always()
  #   env:
  #     TEMPLATE_VERSION: main
  #     FETCH_SAST_ARTIFACTS: 'false'
  #     APP_IMAGE_TAG: "${{ github.sha }}"
  #     APP_IMAGE_SRC: "${BC_IMAGE_REPO}/${{ github.repository }}"
  #     APP_IMAGE: "${APP_IMAGE_SRC}:${APP_IMAGE_TAG}"
  #     ARTIFACT_FOLDER: ".artifacts"
  #     GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
  #     IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
  #     COSIGN_EXPERIMENTAL: 1
  #     AWS_PROFILE: "${BC_AWS_PROFILE_PROD}"
  #     AWS_BUCKET: "${BC_AWS_SECURITY_SCANS_STORAGE_BUCKET_PROD}"
  #     PRODUCT: "${{ github.event.repository.name }}"
  #     ENGAGEMENT: "${{ github.event.repository.name }}_pipeline_${{ github.repository}}/${{ github.workflow }}_${{ github.ref }}"
  #   steps:
  #   - uses: actions/checkout@v4.1.0
  #   - run: mkdir ~/.docker && echo $BC_ARTIFACTORY_AUTH_JSON >> ~/.docker/config.json
  #   - run: export PRODUCT_TYPE=$(basename ${{ github.repository_owner }})
  #   - run: export EXPORT_DATE=$(date -u +"%Y%m%d")
  #   - run: export S3_KEY=${EXPORT_DATE}/${PRODUCT_TYPE}/${PRODUCT}/${ENGAGEMENT}
  #   - run: echo "Omnibus Smoke Test - Ignore" > file-1.txt
  #   - run: ls -la
  #   - run: s3upload -f file-1.txt -b ${AWS_BUCKET} -k ${S3_KEY}
  # oras:
  #   needs: delivery-pipeline
  #   runs-on: ubuntu-latest
  #   container:
  #     image: "${APP_IMAGE}"
  #   if: !(${{ github.event_name }} == "merge_request_event") || always() || !(${{ github.ref }}) || always()
  #   env:
  #     TEMPLATE_VERSION: main
  #     FETCH_SAST_ARTIFACTS: 'false'
  #     APP_IMAGE_TAG: "${{ github.sha }}"
  #     APP_IMAGE_SRC: "${BC_IMAGE_REPO}/${{ github.repository }}"
  #     APP_IMAGE: "${APP_IMAGE_SRC}:${APP_IMAGE_TAG}"
  #     ARTIFACT_FOLDER: ".artifacts"
  #     GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
  #     IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
  #     COSIGN_EXPERIMENTAL: 1
  #     ARTIFACT_TYPE: application/vnd.cms.batcave.smoke-test+text
  #     SMOKE_TEST_IMAGE: "${BC_IMAGE_REPO}/devops-pipelines/cache/omnibus/smoke-test:latest"
  #   steps:
  #   - uses: actions/checkout@v4.1.0
  #   - run: mkdir ~/.docker && echo $BC_ARTIFACTORY_AUTH_JSON >> ~/.docker/config.json
  #   - run: date > omnibus-smoke-test.txt
  #   - run: cat omnibus-smoke-test.txt
  #   - run: oras push -v --artifact-type ${ARTIFACT_TYPE} ${SMOKE_TEST_IMAGE} omnibus-smoke-test.txt
  #   - run: rm omnibus-smoke-test.txt
  #   - run: ls -lah
  #   - run: oras pull -v ${SMOKE_TEST_IMAGE}
  #   - run: cat omnibus-smoke-test.txt
  # workflow-engine:
  #   needs: delivery-pipeline
  #   runs-on: ubuntu-latest
  #   container:
  #     image: "${APP_IMAGE}"
  #   if: !(${{ github.event_name }} == "merge_request_event") || always() || !(${{ github.ref }}) || always()
  #   env:
  #     TEMPLATE_VERSION: main
  #     FETCH_SAST_ARTIFACTS: 'false'
  #     APP_IMAGE_TAG: "${{ github.sha }}"
  #     APP_IMAGE_SRC: "${BC_IMAGE_REPO}/${{ github.repository }}"
  #     APP_IMAGE: "${APP_IMAGE_SRC}:${APP_IMAGE_TAG}"
  #     ARTIFACT_FOLDER: ".artifacts"
  #     GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
  #     IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
  #     COSIGN_EXPERIMENTAL: 1
  #     WFE_BUILD_DIR: "."
  #     WFE_BUILD_DOCKERFILE: Dockerfile
  #     WFE_BUILD_TAG: latest
  #     WFE_BUILD_PLATFORM: linux/amd64
  #     WFE_BUILD_TARGET: build
  #     WFE_BUILD_CACHE_TO: ''
  #     WFE_BUILD_CACHE_FROM: ''
  #     WFE_BUILD_SQUASH_LAYERS: 'false'
  #     WFE_SCAN_IMAGE_TARGET: ''
  #     WFE_ARTIFACT_DIRECTORY: ".artifacts"
  #     WFE_SBOM_FILENAME: sbom.json
  #     WFE_GRYPE_FILENAME: grype.json
  #   steps:
  #   - uses: actions/checkout@v4.1.0
  #   - run: mkdir ~/.docker && echo $BC_ARTIFACTORY_AUTH_JSON >> ~/.docker/config.json
  #   - run: echo "Workflow Engine Smoke Test"
  #   - run: workflow-engine run debug
  # release-tool:
  #   needs: delivery-pipeline
  #   runs-on: ubuntu-latest
  #   container:
  #     image: "${APP_IMAGE}"
  #   if: !(${{ github.event_name }} == "merge_request_event") || always() || !(${{ github.ref }}) || always()
  #   env:
  #     TEMPLATE_VERSION: main
  #     FETCH_SAST_ARTIFACTS: 'false'
  #     APP_IMAGE_TAG: "${{ github.sha }}"
  #     APP_IMAGE_SRC: "${BC_IMAGE_REPO}/${{ github.repository }}"
  #     APP_IMAGE: "${APP_IMAGE_SRC}:${APP_IMAGE_TAG}"
  #     ARTIFACT_FOLDER: ".artifacts"
  #     GITLEAKS_REPORT: "${ARTIFACT_FOLDER}/gitleaks/gitleaks_report.json"
  #     IMAGE_SBOM: "${ARTIFACT_FOLDER}/sbom/sbom.json"
  #     COSIGN_EXPERIMENTAL: 1
  #   steps:
  #   - uses: actions/checkout@v4.1.0
  #   - run: mkdir ~/.docker && echo $BC_ARTIFACTORY_AUTH_JSON >> ~/.docker/config.json
  #   - run: release-cli help
  # release-gitlab:
  #   needs:
  #   - grype
  #   - syft
  #   - gitleaks
  #   - cosign-crane
  #   - gatecheck
  #   - s3upload
  #   - oras
  #   - workflow-engine
  #   - release-tool
  #   runs-on: ubuntu-latest
  #   container:
  #     image: artifactory.cloud.cms.gov/batcave-docker/devops-pipelines/pipeline-tools/omnibus:v1.0.0-rc.10
  #   if: !(${{ github.event_name }} == "merge_request_event") || always() || ${{ github.ref }}
  #   env:
  #     TEMPLATE_VERSION: main
  #     FETCH_SAST_ARTIFACTS: 'false'
  #   steps:
  #   - uses: actions/checkout@v4.1.0
  #   - run: echo "Release to GitLab..."
  #   - uses: softprops/action-gh-release@v0.1.15
  #     with:
  #       tag_name: "${{ github.ref }}"
  #       name: Release ${{ github.ref }}
  #       body: Omnibus Release ${{ github.ref }}
